#include "pch.h"
#include "ShaderUtilities.h"

#include <fstream>

#include "spdlog/spdlog.h"

namespace 
{

	std::optional<GLuint> CompileShader(GLenum shaderType, const std::string& source)
	{
		auto logger = spdlog::get("Engine");

		unsigned int shader = glCreateShader(shaderType);
		if (shader == 0)
		{
			logger->error("An error occurred creating the shader object.");
			return std::nullopt;
		}

		GLenum error = glGetError();
		if (error == GL_INVALID_ENUM)
		{
			logger->error("shaderType is not an accepted value.");
			return std::nullopt;
		}

		const char* source_str = source.c_str();
		glShaderSource(shader, 1, &source_str, NULL);

		error = glGetError();
		if (error == GL_INVALID_VALUE)
		{
			logger->error("shader is not a value generated by OpenGL, or count is less than 0.");
			return std::nullopt;
		}
		else if (error == GL_INVALID_OPERATION)
		{
			logger->error("shader is not a shader object.");
			return std::nullopt;
		}

		glCompileShader(shader);

		error = glGetError();
		if (error == GL_INVALID_VALUE)
		{
			logger->error("shader is not a value generated by OpenGL.");
			return std::nullopt;
		}
		else if (error == GL_INVALID_OPERATION)
		{
			logger->error("shader is not a shader object.");
			return std::nullopt;
		}

		int success;
		glGetShaderiv(shader, GL_COMPILE_STATUS, &success);

		error = glGetError();
		if (error == GL_INVALID_ENUM)
		{
			logger->error("pname is not an accepted value.");
			return std::nullopt;
		}
		else if (error == GL_INVALID_VALUE)
		{
			logger->error("shader is not a value generated by OpenGL.");
			return std::nullopt;
		}
		else if (error == GL_INVALID_OPERATION)
		{
			logger->error("pname is GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, or GL_SHADER_SOURCE_LENGTH but a shader compiler is not supported OR shader does not refer to a shader object.");
			return std::nullopt;
		}

		if (!success)
		{
			char infoLog[512];
			glGetShaderInfoLog(shader, 512, NULL, infoLog);

			error = glGetError();
			if (error == GL_INVALID_VALUE)
				logger->error("shader is not a value generated by OpenGL OR maxLength is less than 0.");
			else if (error == GL_INVALID_OPERATION)
				logger->error("shader is not a shader object.");
			else
				logger->error(infoLog);

			return std::nullopt;
		}

		logger->debug(std::format("CompileShader returned {}.", shader));
		return shader;
	}


	std::string ReadFile(const std::filesystem::path& path)
	{
		std::ifstream ifs(path);
		std::stringstream buffer;
		buffer << ifs.rdbuf();

		std::string str(buffer.str());
		return str;
	}

}

namespace GraphicsEngine::ShaderUtilities
{

	std::optional<GLuint> CompileFragmentShader(const std::filesystem::path& path)
	{
		return CompileFragmentShader(ReadFile(path));
	}

	std::optional<GLuint> CompileFragmentShader(const std::string& source)
	{
		spdlog::get("Engine")->debug(std::format("Fragment Shader Source:\n{}", source));
		return CompileShader(GL_FRAGMENT_SHADER, source);
	}

	std::optional<GLuint> CompileVertexShader(const std::filesystem::path& path)
	{
		return CompileVertexShader(ReadFile(path));
	}

	std::optional<GLuint> CompileVertexShader(const std::string& source)
	{
		spdlog::get("Engine")->debug(std::format("Vertex Shader Source:\n{}", source));
		return CompileShader(GL_VERTEX_SHADER, source);
	}

	std::optional<GLuint> LinkProgram(const std::vector<GLuint>& shaders)
	{
		auto logger = spdlog::get("Engine");

		unsigned int shaderProgram = glCreateProgram();
		if (shaderProgram == 0)
		{
			logger->error("An error occurred creating the program object.");
			return std::nullopt;
		}

		GLenum error;
		for (auto shader : shaders)
		{
			glAttachShader(shaderProgram, shader);
			error = glGetError();
			if (error == GL_INVALID_VALUE)
			{
				logger->error("either program or shader is not a value generated by OpenGL.");
				return std::nullopt;
			}
			else if (error == GL_INVALID_OPERATION)
			{
				logger->error("program is not a program object OR shader is not a shader object OR shader is already attached to program.");
				return std::nullopt;
			}
		}
		
		glLinkProgram(shaderProgram);
		error = glGetError();
		if (error == GL_INVALID_VALUE)
		{
			logger->error("program is not a value generated by OpenGL.");
			return std::nullopt;
		}
		else if (error == GL_INVALID_OPERATION)
		{
			logger->error("program is not a program object OR program is the currently active program object and transform feedback mode is active.");
			return std::nullopt;
		}

		int success;
		glGetProgramiv(shaderProgram, GL_LINK_STATUS, &success);
		error = glGetError();
		if (error == GL_INVALID_ENUM)
		{
			logger->error("pname is not an accepted value.");
			return std::nullopt;
		}
		else if (error == GL_INVALID_VALUE)
		{
			logger->error("program  is not a value generated by OpenGL.");
			return std::nullopt;
		}
		else if (error == GL_INVALID_OPERATION)
		{
			logger->error("program does not refer to a program object.");
			return std::nullopt;
		}

		if (!success) 
		{
			char infoLog[512];
			glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);
			error = glGetError();
			if (error == GL_INVALID_VALUE)
				logger->error("program is not a value generated by OpenGL OR maxLength is less than 0.");
			else if (error == GL_INVALID_OPERATION)
				logger->error("program is not a program object.");
			else
				logger->error(infoLog);

			return std::nullopt;
		}

		for (auto shader : shaders)
		{
			glDeleteShader(shader);
			error = glGetError();
			if (error == GL_INVALID_VALUE)
				logger->warn("shader is not a value generated by OpenGL.");
		}

		logger->debug(std::format("LinkProgram returned {}.", shaderProgram));
		return shaderProgram;
	}

	std::optional<bool> ShaderIsDeleted(GLuint shader)
	{
		auto logger = spdlog::get("Engine");

		GLint param;
		glGetShaderiv(shader, GL_DELETE_STATUS, &param);

		switch (glGetError())
		{
		case GL_INVALID_VALUE:
			logger->warn("shader it not a value generated by OpenGL.");
			return std::nullopt;
		case GL_INVALID_OPERATION:
			logger->warn("shader does not refer to a shader object.");
			return std::nullopt;
		case GL_INVALID_ENUM:
			logger->warn("pname is not an accepted value.");
			return std::nullopt;
		}

		return (param == GL_TRUE) ? true : false;
	}

}
